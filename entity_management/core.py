'''
Provenance entities

.. inheritance-diagram:: entity_management.core
   :top-classes: entity_management.base.BlankNode,
    entity_management.base.Identifiable
   :parts: 1
'''
import os
import json
import uuid
from datetime import datetime
from typing import List
from io import StringIO

import attr
from attr.validators import in_

from entity_management import nexus
from entity_management.base import Identifiable, BlankNode, OntologyTerm, attributes
from entity_management.util import AttrOf, NotInstantiated
from entity_management.settings import AGENT, JSLD_ID


@attributes({
    'name': AttrOf(str, default=None),
    'license': AttrOf(Identifiable, default=None),
    'contentUrl': AttrOf(str, default=None),
    'url': AttrOf(str, default=None),
    'contentSize': AttrOf(dict, default=None),
    'digest': AttrOf(dict, default=None),
    'encodingFormat': AttrOf(str, default=None),
})
class DataDownload(BlankNode):
    '''External resource representations, this can be a file or a folder on gpfs.

    Args:
        name (str): The distribution name.
        license (Identifiable): A Link towards the distribution license.
        contentUrl (str): When followed this link leads to the actual data.
        url (str): When followed this link leads to a resource providing further description on
            how to download the attached data.
        contentSize (int): If known in advance size of the resource.
        digest (int): Hash/Checksum of the resource.
        encodingFormat (str): Type of the resource accessible by the contentUrl.

    either `downloadURL` for files or `accessURL` for folders must be provided'''

    def __attrs_post_init__(self):
        super(DataDownload, self).__attrs_post_init__()
        if not self.contentUrl and not self.url:  # pylint: disable=no-member
            raise ValueError('"contentUrl" or "url" must be provided!')

    @classmethod
    def from_file(cls, file_path, name=None, resource_id=None,
                  content_type='application/octet-stream', use_auth=None):
        '''Create DataDownload object form file_path.

        Args:
            file_path (str): Path to the file.
            name (str): Optional name for the DataDownload name property. If not provided
                file name with extension from the `file_path` will be used.
            resource_id (str): Optional file resource identifier. If not provided will be
                generated by Nexus.
            content_type (str): File content type for example: `text/plain`. Default value:
                `application/octet-stream`.
            use_auth (str): Optional OAuth token.
        '''
        file_name = os.path.basename(file_path)
        with open(file_path, 'rb') as f:
            resp = nexus.upload_file(file_name, f, content_type, resource_id=resource_id,
                                     token=use_auth)
        return DataDownload(name=name if name else file_name,
                            contentSize={'unitCode': 'bytes', 'value': resp['_bytes']},
                            digest={'algorithm': resp['_digest']['_algorithm'],
                                    'value': resp['_digest']['_value']},
                            encodingFormat=resp['_mediaType'],
                            contentUrl=resp[JSLD_ID],
                            url=resp['_self'])

    @classmethod
    def from_dict(cls, dict_, resource_id=None, use_auth=None):
        '''Create DataDownload object representing json form dict.

        Args:
            dict_ (dict): Path to the file.
            resource_id (str): Optional file resource identifier. If not provided will be
                generated by Nexus.
            use_auth (str): Optional OAuth token.
        '''
        buff = StringIO()
        json.dump(dict_, buff)
        buff.seek(0)
        file_name = str(uuid.uuid4())
        resp = nexus.upload_file(file_name, buff, 'application/json', resource_id=resource_id,
                                 token=use_auth)
        return DataDownload(contentSize={'unitCode': 'bytes', 'value': resp['_bytes']},
                            digest={'algorithm': resp['_digest']['_algorithm'],
                                    'value': resp['_digest']['_value']},
                            encodingFormat=resp['_mediaType'],
                            contentUrl=resp[JSLD_ID],
                            url=resp['_self'])

    def download(self, path=None, file_name=None, use_auth=None):
        '''Download ``contentUrl``.

        Args:
            path (str): Optional path where to save the file. If not provided current folder will
                be used.
            file_name (str): Optional file name.  If not provided, file name will be taken from
                the name stored in Nexus.
            use_auth (str): Optional OAuth token.
        '''
        # pylint: disable=no-member
        assert self.contentUrl is not None, 'No contentUrl!'

        if path is None:
            path = os.getcwd()
        return nexus.download_file(self.contentUrl, path, file_name, token=use_auth)

    def as_dict(self, use_auth=None):
        '''Get ``contentUrl`` as dict.

        Args:
            use_auth (str): Optional OAuth token.
        '''
        # pylint: disable=no-member
        assert self.contentUrl is not None, 'No contentUrl!'
        assert self.encodingFormat == 'application/json', ('Wrong encodingFormat, '
                                                           'expecting application/json!')

        return nexus.file_as_dict(self.contentUrl, token=use_auth)


@attributes({'distribution': AttrOf(List[DataDownload], default=None)})
@attr.s
class DistributionMixin(object):
    '''Provide `distribution` attribute.
    attach/download corresponding operations on the distribution.
    '''


@attributes()
class Agent(Identifiable):
    '''Agent.

    Args:
        name(str): Name of the agent.
    '''


@attributes({'email': AttrOf(str),
             'name': AttrOf(str, default=None),
             'givenName': AttrOf(str, default=None),
             'familyName': AttrOf(str, default=None)})
class Person(Agent):
    '''Person.

    Args:
        email(str): Email.
        givenName(str): Given name.
        familyName(str): Family name.
    '''


@attributes({
    'version': AttrOf(str)
})
class SoftwareAgent(Agent):
    '''Software agent

    Args:
        version(str): Version of the software used.
    '''


@attributes({
    'name': AttrOf(str, default=None),
    'status': AttrOf(str, default=None, validators=in_([None,
                                                        'Pending',
                                                        'Running',
                                                        'Done',
                                                        'Failed'])),
    'used': AttrOf(Identifiable, default=None),
    'generated': AttrOf(Identifiable, default=None),
    'startedAtTime': AttrOf(datetime, default=None),
    'endedAtTime': AttrOf(datetime, default=None),
    'wasStartedBy': AttrOf(Agent, default=None),
})
class Activity(Identifiable):
    '''Base class for provenance activity.

    Args:
        name (str): Activity name.
        status (str): Status can be `None`, `Pending`, `Running`, `Done` or `Failed`.
        used (Identifiable): Entity used by this activity.
        generated (Identifiable): Entity generated by this activity.
        startedAtTime (datetime): Activity start time.
        endedAtTime (datetime): Activity end time.
        wasStartedBy (Agent): Agent which started the activity.
    '''

    def __attrs_post_init__(self):
        # only init for newly created entities
        attr_value = object.__getattribute__(self, 'startedAtTime')
        if (attr_value is not NotInstantiated  # skip lazy loaded entities
                and self._id is None and self.startedAtTime is None):  # pylint: disable=no-member
            self._force_attr('startedAtTime', datetime.utcnow())


@attributes({
    'wasAttributedTo': AttrOf(List[Agent], default=None),
    'wasDerivedFrom': AttrOf(List[Identifiable], default=None),
    'dateCreated': AttrOf(datetime, default=None)
})
class ProvenanceMixin(object):
    '''Enables provenance metadata when publishing/deprecating entities'''

    def publish(self, resource_id=None, activity=None, person=None, use_auth=None):
        '''Create or update resource in nexus. Makes a remote call to nexus instance to persist
        resource attributes. If ``use_auth`` token is provided user agent will be extracted
        from it and corresponding activity with ``createdBy`` field will be created.

        Args:
            resource_id (str): Resource identifier.
            activity (Activity): Provide custom activity to link with
                generated resource new revision otherwise default activity will be created.
            person (Person): Provide person argument in order to set explicitly entity attribution
                parameter ``wasAttributedTo``. If runnning in the context of a workflow(when
                NEXUS_AGENT env variable is provided) resource will be attributted to the
                Workflow agent.
            use_auth (str): OAuth token in case access is restricted.
                Token should be in the format for the authorization header: Bearer VALUE.
        Returns:
            New instance of the same class with revision updated.
        '''
        if activity is not None:
            assert isinstance(activity, Activity)

        if AGENT is not None:
            # in case running in the context of externally provided agent
            agent = Agent.from_id(AGENT)
        else:
            agent = person

        if self._self:
            json_ld = nexus.update(self._self, self._rev, self.as_json_ld(), token=use_auth)
        else:
            if agent:
                self = self.evolve(wasAttributedTo=[agent])
            json_ld = nexus.create(self.get_base_url(),
                                   self.as_json_ld(),
                                   resource_id,
                                   token=use_auth)

        self._force_attr('_id', json_ld.get(JSLD_ID))
        self._force_attr('_rev', json_ld.get('_rev'))
        self._force_attr('_self', json_ld.get('_self'))

        if activity is not None:
            activity = activity.evolve(generated=self, wasStartedBy=agent)
            activity.publish(use_auth=use_auth)

        return self


@attributes({
    'name': AttrOf(str),
    'description': AttrOf(str, default=None),
    'distribution': AttrOf(DataDownload, default=None),
})
class Entity(ProvenanceMixin, Identifiable):
    '''Generic class for core Entities.'''


@attributes({
    'name': AttrOf(str),
    'module': AttrOf(str),
    'task': AttrOf(str),
    'version': AttrOf(str),
    'parameters': AttrOf(str, default=None),
    'distribution': AttrOf(DataDownload, default=None),
})
class WorkflowExecution(Activity):
    '''Represents activity of a workflow execution.

    Args:
        name (str): The user friendly workflow execution entry point. By convention will contain
            user name, full name of a luigi task which was executed and a timestamp.
        module (str): Python module which was used to launch the luigi task from.
        task (str): Luigi task which was launched for execution.
        version (str): Version of the workflow engine used to execute the workflow.
        parameters (str): Concatenated list of parameters provided on the command line
            when the workflow was launched.
        distribution (DataDownload): Zip file of the additional python modules and the configuration
            file used to launch the workflow.
    '''


@attributes({
    'name': AttrOf(str, default=None),
    'species': AttrOf(OntologyTerm, default=None),
    'strain': AttrOf(OntologyTerm, default=None),
})
class Subject(ProvenanceMixin, DistributionMixin, Identifiable):
    '''Subject.

    Args:
        name (str): Subject name.
        species (OntologyTerm): Species ontology term.
        strain (OntologyTerm): Strain ontology term.
    '''
